generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
}

model User {
  id        String   @id @default(cuid())
  username  String   @unique
  email     String?  @unique
  password  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  player    Player?
}

model Player {
  id                 String          @id @default(cuid())
  userId             String          @unique
  race               String
  wood               Float           @default(500)
  iron               Float           @default(300)
  gold               Float           @default(200)
  doblones           Float           @default(100)
  etherFragments     Float           @default(0)
  populationUsed     Int             @default(0)
  populationMax      Int             @default(200)
  lastResourceUpdate DateTime        @default(now())
  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt
  bio                String?          @db.Text
  experience         Int             @default(0)
  level              Int             @default(1)
  militaryPower      Int             @default(0)
  allianceMember     AllianceMember?
  city               City?
  attackerReports    CombatReport[]  @relation("AttackerReports")
  defenderReports    CombatReport[]  @relation("DefenderReports")
  receivedMessages   Message[]       @relation("ReceivedMessages")
  sentMessages       Message[]       @relation("SentMessages")
  exchangeOrders     ExchangeOrder[]
  tradeListings      TradeListing[]
  user               User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([militaryPower])
}

model Alliance {
  id          String           @id @default(cuid())
  name        String           @unique
  tag         String           @unique
  description String?
  createdAt   DateTime         @default(now())
  members     AllianceMember[]
}

model AllianceMember {
  id         String   @id @default(cuid())
  allianceId String
  playerId   String   @unique
  rank       String   @default("MEMBER")
  joinedAt   DateTime @default(now())
  alliance   Alliance @relation(fields: [allianceId], references: [id], onDelete: Cascade)
  player     Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([allianceId, playerId])
}

model City {
  id                String                  @id @default(cuid())
  name              String
  playerId          String                  @unique
  createdAt         DateTime                @default(now())
  updatedAt         DateTime                @updatedAt
  x                 Int                     @default(0)
  y                 Int                     @default(0)
  buildings         Building[]
  player            Player                  @relation(fields: [playerId], references: [id], onDelete: Cascade)
  originMovements   CombatMovement[]        @relation("OriginMovements")
  targetMovements   CombatMovement[]        @relation("TargetMovements")
  constructionQueue ConstructionQueueItem[]
  trainingQueue     TrainingQueueItem[]
  units             Unit[]
}

model Building {
  id     String @id @default(cuid())
  type   String
  level  Int    @default(0)
  cityId String
  city   City   @relation(fields: [cityId], references: [id], onDelete: Cascade)

  @@unique([cityId, type])
}

model ConstructionQueueItem {
  id           String   @id @default(cuid())
  buildingType String
  targetLevel  Int
  startTime    DateTime @default(now())
  endTime      DateTime
  cityId       String
  createdAt    DateTime @default(now())
  city         City     @relation(fields: [cityId], references: [id], onDelete: Cascade)

  @@index([endTime])
}

model Unit {
  id     String @id @default(cuid())
  type   String
  count  Int    @default(0)
  cityId String
  city   City   @relation(fields: [cityId], references: [id], onDelete: Cascade)

  @@unique([cityId, type])
}

model TrainingQueueItem {
  id        String   @id @default(cuid())
  unitType  String
  count     Int
  startTime DateTime @default(now())
  endTime   DateTime
  cityId    String
  createdAt DateTime @default(now())
  city   City   @relation(fields: [cityId], references: [id], onDelete: Cascade)

  @@index([endTime])
}

model CombatMovement {
  id           String   @id @default(cuid())
  type         String
  originCityId String
  targetCityId String
  startTime    DateTime @default(now())
  endTime      DateTime
  units        Json
  wood         Float    @default(0)
  iron         Float    @default(0)
  gold         Float    @default(0)
  createdAt    DateTime @default(now())
  originCity   City     @relation("OriginMovements", fields: [originCityId], references: [id])
  targetCity   City     @relation("TargetMovements", fields: [targetCityId], references: [id])

  @@index([endTime])
}

model CombatReport {
  id             String   @id @default(cuid())
  attackerId     String
  defenderId     String
  originCityName String
  targetCityName String
  won            Boolean
  troopSummary   Json
  lootedWood     Float    @default(0)
  lootedIron     Float    @default(0)
  lootedGold     Float    @default(0)
  timestamp      DateTime @default(now())
  read           Boolean  @default(false)
  attacker       Player   @relation("AttackerReports", fields: [attackerId], references: [id])
  defender       Player   @relation("DefenderReports", fields: [defenderId], references: [id])
}

model Message {
  id                 String   @id @default(cuid())
  subject            String
  content            String
  senderId           String
  recipientId        String
  read               Boolean  @default(false)
  createdAt          DateTime @default(now())
  deletedBySender    Boolean  @default(false)
  deletedByRecipient Boolean  @default(false)
  recipient          Player   @relation("ReceivedMessages", fields: [recipientId], references: [id])
  sender             Player   @relation("SentMessages", fields: [senderId], references: [id])
}

model ExchangeOrder {
  id        String   @id @default(cuid())
  playerId  String
  type      String   // "BUY" | "SELL"
  amount    Float
  price     Float    // En Doblones por Fragmento
  status    String   @default("OPEN") // "OPEN" | "FILLED" | "CANCELLED"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  player    Player   @relation(fields: [playerId], references: [id])

  @@index([price])
  @@index([status])
}

model TradeListing {
  id               String   @id @default(cuid())
  sellerId         String
  offeredType      String   // WOOD, IRON, GOLD, DOBLONES, ETHER
  offeredAmount    Float
  requestedType    String   // WOOD, IRON, GOLD, DOBLONES, ETHER
  requestedAmount  Float
  status           String   @default("OPEN") // "OPEN", "FILLED", "CANCELLED"
  createdAt        DateTime @default(now())
  seller           Player   @relation(fields: [sellerId], references: [id])

  @@index([status])
  @@index([offeredType])
  @@index([requestedType])
}

model MarketHistory {
  id             String   @id @default(cuid())
  price          Float
  volume         Float
  type           String   @default("BUY") // "BUY" | "SELL"
  timestamp      DateTime @default(now())

  @@index([timestamp])
}
model MarketState {
  id             String   @id @default("global")
  etherReserve   Float    @default(100000) // Reserva virtual de Ã‰ter
  doblonesReserve Float   @default(50000000) // Reserva virtual de Doblones (Precio inicial ~500)
  lastUpdate     DateTime @default(now())
}
